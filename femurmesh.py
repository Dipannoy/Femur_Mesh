# -*- coding: utf-8 -*-
"""FemurMesh.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SwYHWuzen7bNtHT7ILziYRQz0XFCLqqA
"""

from google.colab import drive
drive.mount('/gdrive',force_remount=True)

pip install open3d pydicom opencv-python

pip install numpy-stl

!apt-get install -y graphviz libgraphviz-dev libcgraph6

import open3d as o3d

# import open3d as o3d
import numpy as np
import cv2
import pydicom
import os
import matplotlib.pyplot as plt
from glob import glob
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
##import skimage
import scipy.ndimage
import imageio
from skimage import morphology
from skimage import measure
from skimage.transform import resize
from sklearn.cluster import KMeans
from plotly import __version__
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
from plotly.tools import FigureFactory as FF
from plotly.graph_objs import *
##init_notebook_mode(connected=True)

import scipy.sparse as sp
import tensorflow as tf
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.losses import CategoricalCrossentropy
from tensorflow.keras.metrics import categorical_accuracy
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam

import matplotlib.pyplot as plt
import numpy as np

from skimage.data import astronaut
from skimage.color import rgb2gray
from skimage.filters import sobel
from skimage.segmentation import felzenszwalb, slic, quickshift, watershed
from skimage.segmentation import mark_boundaries
import copy


# from spektral.data import Dataset, DisjointLoader, Graph
# from spektral.layers import GCSConv, GlobalAvgPool, AGNNConv, APPNPConv,ARMAConv
# from spektral.layers.pooling import TopKPool
# from spektral.transforms.normalize_adj import NormalizeAdj

data_path = "/gdrive/My Drive/BD066"
# output_path = working_path = "F:\SelfContent\DeepLearningWork\ImageProcessing"
img = os.path.join("/gdrive/My Drive/BD066","file")

def load_scan(path):
    slices = [pydicom.read_file(path + '/' + s) for s in os.listdir(path)]
    print(np.abs(slices[20].ImagePositionPatient[2] - slices[21].ImagePositionPatient[2]))
    # slices = []
    # files = os.listdir(path)
    # fileLength = len(files) // 2
    # for i in range(fileLength) :
    #     slc = pydicom.read_file(path + '/' + files[i])
    #     slices.append(slc)
        


    slices.sort(key = lambda x: int(x.InstanceNumber))
    try:
        slice_thickness = np.abs(slices[0].ImagePositionPatient[2] - slices[1].ImagePositionPatient[2])
        
    except:
        slice_thickness = np.abs(slices[0].SliceLocation - slices[1].SliceLocation)
        
    for s in slices:
        s.SliceThickness = slice_thickness
        
    return slices


def get_pixels_hu(scans):
    print(len(scans[0]))
    #print(scans[0].pixel_array)
    #out_tpl = np.nonzero(scans[0].pixel_array)
    out_arr = scans[0].pixel_array[np.nonzero(scans[0].pixel_array)]
    print(len(out_arr))
    #image = np.stack([scans[s].pixel_array for s in range(1, len(scans)//2)])
    image = np.stack([s.pixel_array  for s in scans])
    # Convert to int16 (from sometimes int16), 
    # should be possible as values should always be low enough (<32k)
    image = image.astype(np.int16)
    

    # Set outside-of-scan pixels to 1
    # The intercept is usually -1024, so air is approximately 0
    # image[image == -2000] = 0
    # image = image[image == 30]
    
    # Convert to Hounsfield units (HU)
    # --------------------------------------
    intercept = scans[0].RescaleIntercept
    slope = scans[0].RescaleSlope
    
    if slope != 1:
        image = slope * image.astype(np.float64)
        image = image.astype(np.int16)
        
    image += np.int16(intercept)
    # --------------------------------------
    # image[image != 0] = 0
    # print(len(image))
    # print(image)
    # image2 = image[(image >= 500) & (image <= 3000)]

    # --------------------------------------------------
    image[image < 100] = 0
    # image[image < 900] = -1000


    
    

    
    return np.array(image, dtype=np.int16)
id=0
patient = load_scan(data_path)
imgs = get_pixels_hu(patient)
# print(len(imgs))
# print ("Shape before resampling\t", imgs.shape)

print(slices[0])

print(np.max(np.nonzero(tempCropImageArray[250])))

cropImageArray = []
resizeImageArray = []
for i in range(522):

  cropImage = imgs[i][120:350,100:250]
  cropImageArray.append(cropImage)

  # res = cv2.resize(cropImage, dsize=(10, 10), interpolation=cv2.INTER_CUBIC)
  # resizeImageArray.append(res)

plt.imshow(cropImage)
plt.show()

# cropImage = copy.deepcopy(cropImageArray[46][98:148,:])
cropImage = copy.deepcopy(cropImageArray[21])
plt.imshow(cropImage)
plt.show()

print(cropImage.shape)

class Subset:
  def __init__(self, start, end, length, avg,total):
    self.start = start
    self.end = end
    self.length = length
    self.avg = avg
    self.total = total

cropImage = copy.deepcopy(cropImageArray[42])

def getNonZeroPixelRegion(Image):
  IsSub = False
  lent = 0
  start = -1
  finish = -1
  subList = []
  subListList = []
  totalPixel = 0
  avgPixel = 0
  shape = np.array(Image.shape)
  imgg = copy.deepcopy(Image)
  
  for i in range(shape[1]):
    start = -1
    finish = -1
    lent = 0
    IsSub = False
    totalPixel = 0
    avgPixel = 0
    subList = []
    for j in range(shape[0]):
      if imgg[j][i] != 0 and IsSub == False :
        start = j
        IsSub = True
      if imgg[j][i] == 0 and IsSub == True :
        finish = j-1
        avgPixel = totalPixel / lent
        subList.append(Subset(start,finish,lent,avgPixel,totalPixel))
        start = -1
        finish = -1
        lent = 0
        IsSub = False
        totalPixel = 0
        avgPixel = 0
      if imgg[j][i] != 0 and IsSub == True :
        lent = lent + 1
        totalPixel = totalPixel + imgg[j][i]
    subListList.append(subList)
  return subListList

def getNonZeroPixelRegionHorizontally(Image):
  IsSub = False
  lent = 0
  start = -1
  finish = -1
  subList = []
  subListList = []
  totalPixel = 0
  avgPixel = 0
  shape = np.array(Image.shape)
  imgg = copy.deepcopy(Image)
  
  for i in range(shape[0]):
    start = -1
    finish = -1
    lent = 0
    IsSub = False
    totalPixel = 0
    avgPixel = 0
    subList = []
    for j in range(shape[1]):
      if imgg[i][j] != 0 and IsSub == False :
        start = j
        IsSub = True
      if imgg[i][j] == 0 and IsSub == True :
        finish = j-1
        avgPixel = totalPixel / lent
        subList.append(Subset(start,finish,lent,avgPixel,totalPixel))
        start = -1
        finish = -1
        lent = 0
        IsSub = False
        totalPixel = 0
        avgPixel = 0
      if imgg[i][j] != 0 and IsSub == True :
        lent = lent + 1
        totalPixel = totalPixel + imgg[i][j]
    subListList.append(subList)
  return subListList

# cropImage = copy.deepcopy(cropImageArray[40])
def noiseRemovalCluster(testImg):
  cropImage = testImg
  IsSub = False
  lent = 0
  start = -1
  finish = -1
  subList = []
  subListList = []
  totalPixel = 0
  avgPixel = 0
  shape = np.array(cropImage.shape)
  imgg = copy.deepcopy(cropImage)
  
  for i in range(shape[1]):
    start = -1
    finish = -1
    lent = 0
    IsSub = False
    totalPixel = 0
    avgPixel = 0
    subList = []
    for j in range(shape[0]):
      if imgg[j][i] != 0 and IsSub == False :
        start = j
        IsSub = True
      if imgg[j][i] == 0 and IsSub == True :
        finish = j-1
        avgPixel = totalPixel / lent
        subList.append(Subset(start,finish,lent,avgPixel,totalPixel))
        start = -1
        finish = -1
        lent = 0
        IsSub = False
        totalPixel = 0
        avgPixel = 0
      if imgg[j][i] != 0 and IsSub == True :
        lent = lent + 1
        totalPixel = totalPixel + imgg[j][i]
    subListList.append(subList)
  return subListList

def modifiedImage(Image,subListList):
  shape = np.array(Image.shape)
  for i in range(shape[1]):
    if len(subListList[i]) > 0:
      for j in range(0,len(subListList[i])):
        
        if subListList[i][j].avg < 150 or subListList[i][j].avg > 450 :
        # if subListList[i][j].avg > 600 :
          for k in range(subListList[i][j].start,subListList[i][j].end):
            Image[k][i] = 0
  return Image

def modifiedImageHorizontally(Image,subListList):
  shape = np.array(Image.shape)
  for i in range(shape[0]):
    if len(subListList[i]) > 0:
      for j in range(0,len(subListList[i])):
        
        if subListList[i][j].avg < 150 or subListList[i][j].avg > 450 :
        # if subListList[i][j].avg > 600 :
          for k in range(subListList[i][j].start,subListList[i][j].end):
            Image[i][k] = 0
  return Image

for i in range(shape[0]):
  subListList[i].sort(key=lambda x: x.length, reverse=True)
  if len(subListList[i]) > 1 and subListList[i][1].end + 1 < shape[1]:
    if len(subListList[i]) == 2:

      for j in range(subListList[i][1].end + 1, shape[1]):
        cropImage[i][j] = 0

for i in range(shape[1]):
  subListList[i].sort(key=lambda x: x.length, reverse=True)
  if len(subListList[i]) > 1 and subListList[i][0].end + 1 < shape[0]:
      for j in range(subListList[i][0].end + 1, shape[0]):
        cropImage[j][i] = 0
      for j in range(0, subListList[i][0].start + 1):
        cropImage[j][i] = 0

def removeNoise(segImage, segList):
  segShape = np.array(segImage.shape)
  for i in range(segShape[1]):
    # print(i)
    if len(segList[i]) > 0:
      for j in range(0,len(segList[i])):
        if segList[i][j].avg < 200:
          #400
          # print(subListList[i][j].avg)
          for k in range(segList[i][j].start,segList[i][j].end+1):
            # print('done')
            segImage[k][i] = 0
  return segImage

plt.imshow(tempCropImageArray[50])
plt.show()

for i in range(shape[0]):
  if len(subListList[i]) > 0:
    if len(subListList[i]) == 3:
      for j in range(0,len(subListList[i])):
        for k in range(subListList[i][j].start,subListList[i][j].end):
          cropImage[i][k] = 0

for i in range(shape[0]):
  if len(subListList[i]) > 0:
    for j in range(0,len(subListList[i])):
      
      if subListList[i][j].avg < 200 or subListList[i][j].avg > 450 :
        for k in range(subListList[i][j].start,subListList[i][j].end):
          cropImage[i][k] = 0

imgShape = np.array(cropImageArray[40].shape)
cropImage = copy.deepcopy(cropImageArray[40][:,38:imgShape[1]])
cropShape = np.shape(cropImage)

for i in range(cropShape[0]):
  for j in range(50,cropShape[1]):
    cropImage[i][j] = 0

for i in range(22,32):
  if i%2 ==0:
    plt.imshow(tempCropImageArray[i])
    plt.show()

import cv2_imshow

# cropImage = copy.deepcopy(cropImageArray[250][:,0:80])
# plt.imshow(cropImageArray[250])
# plt.show()
# plt.imshow(cropImageArray[54])
# plt.show()
input_image = cropImageArray[54].astype(np.uint8)
input_image = cv2.threshold(input_image, 254, 255, cv2.THRESH_BINARY)[1]
input_image_comp = cv2.bitwise_not(input_image)  # could just use 255-img

kernel1 = np.array([[0, 0, 0],
                    [0, 1, 0],
                    [0, 0, 0]], np.uint8)
kernel2 = np.array([[1, 1, 1],
                    [1, 0, 1],
                    [1, 1, 1]], np.uint8)

hitormiss1 = cv2.morphologyEx(input_image, cv2.MORPH_ERODE, kernel1)
hitormiss2 = cv2.morphologyEx(input_image_comp, cv2.MORPH_ERODE, kernel2)
hitormiss = cv2.bitwise_and(hitormiss1, hitormiss2)

plt.imshow(hitormiss)
plt.show()

hitormiss_comp = cv2.bitwise_not(hitormiss)  # could just use 255-img
del_isolated = cv2.bitwise_and(input_image, input_image, mask=hitormiss_comp)

plt.imshow(del_isolated)
plt.show()

tempCropImageArray = copy.deepcopy(cropImageArray)

for i in range(52,62):
  if i % 2 ==0:
    plt.imshow(cropImageArray[i])
    plt.show()

def sumPixelImageHorizontally(Image,subListList):
  shape = np.array(Image.shape)
  for i in range(shape[0]):
    total = 0;
    if len(subListList[i]) > 0:
      for j in range(0,len(subListList[i])):
        total = total + subListList[i][j].total
        # if subListList[i][j].avg < 150 or subListList[i][j].avg > 450 :
    if total < 13000 :
      for k in range(shape[1]):
        Image[i][k] = 0
  return Image

def makeZeroPixel(image, x_start, x_end, y_start, y_end,towards_x, towards_y):
  x_shape = np.array(image.shape)[0]
  y_shape = np.array(image.shape)[1]
  if towards_x == True:
    for i in range(x_shape):
      for j in range(x_start,x_end):
        image[i][j] = 0
  if towards_y == True:
    for i in range(y_shape):
      for j in range(y_start, y_end):
        image[j][i] = 0
  return image

plt.imshow(tempCropImageArray[18])
plt.show()

# for i in range(14,16):
#   if i % 2 == 0:

# Slice 20 - 19000
# Slice 18 - 19000
# Slice 16 - 13000
# Slice 14 - 13000
opImage = copy.deepcopy(cropImageArray[14])
sSubList = getNonZeroPixelRegionHorizontally(opImage)
img = sumPixelImageHorizontally(opImage,sSubList)

subbList = noiseRemovalCluster(img)
noiseFree =  removeNoise(img,subbList)
cutImage = copy.deepcopy(noiseFree)
cutImage = makeZeroPixel(cutImage,90,130,135,200,True,True)
cutImage = makeZeroPixel(cutImage,90,130,0,100,True,True)

tempCropImageArray[14] = cutImage
plt.imshow(cutImage)
plt.show()


    # plt.show()

plt.imshow(tempCropImageArray[14])
plt.show()

loopImageShape = np.array(cropImageArray[40].shape)

loopImageShape = np.array(cropImageArray[40].shape)
for k in range(18,22):
  if k % 2 == 0:
    cropImage = copy.deepcopy(cropImageArray[k][:,50:loopImageShape[1]])
    drawImage = copy.deepcopy(cropImageArray[k])
    cropShape = np.shape(cropImage)

    for i in range(cropShape[0]):
      for j in range(40,cropShape[1]):
        cropImage[i][j] = 0
    slist = getNonZeroPixelRegion(cropImage)
  
    modImage = modifiedImage(cropImage,slist)
    
    for x in range(loopImageShape[0]):
      y_coord = 0
      for y in range(50,loopImageShape[1]):
        drawImage[x][y] = modImage[x][y_coord]

        y_coord = y_coord + 1
    tempCropImageArray[k] = drawImage

    plt.imshow(drawImage)
    plt.show()

for k in range(32,50):
  if k % 2 == 0:
     plt.imshow(tempCropImageArray[k])
     plt.show()

loopImageShape = np.array(cropImageArray[40].shape)
for k in range(22,32):
  if k % 2 == 0:
    cropImage = copy.deepcopy(cropImageArray[k][:,50:loopImageShape[1]])
    drawImage = copy.deepcopy(cropImageArray[k])
    cropShape = np.shape(cropImage)

    for i in range(cropShape[0]):
      for j in range(40,cropShape[1]):
        cropImage[i][j] = 0
    slist = getNonZeroPixelRegionHorizontally(cropImage)
  
    modImage = modifiedImageHorizontally(cropImage,slist)
    
    for x in range(loopImageShape[0]):
      y_coord = 0
      for y in range(50,loopImageShape[1]):
        drawImage[x][y] = modImage[x][y_coord]

        y_coord = y_coord + 1
    cutImage = makeZeroPixel(drawImage,90,140,140,200,True,True)
    cutImage = makeZeroPixel(cutImage,90,140,0,105,True,True)

    tempCropImageArray[k] = cutImage

    plt.imshow(cutImage)
    plt.show()



loopImageShape = np.array(cropImageArray[40].shape)
# for k in range(22,32):
for k in range(52,62):
  if k % 2 == 0:
    # cropImage = copy.deepcopy(cropImageArray[k][:,50:loopImageShape[1]])
    cropImage = copy.deepcopy(cropImageArray[k])

    drawImage = copy.deepcopy(cropImageArray[k])
    cropShape = np.shape(cropImage)

    # for i in range(cropShape[0]):
    #   for j in range(40,cropShape[1]):
    #     cropImage[i][j] = 0
    slist = getNonZeroPixelRegionHorizontally(cropImage)
  
    modImage = modifiedImageHorizontally(cropImage,slist)

    slistVert = getNonZeroPixelRegion(modImage)
    modImage = modifiedImage(modImage, slistVert)
    
    for x in range(loopImageShape[0]):
      y_coord = 0
      for y in range(0,loopImageShape[1]):
        drawImage[x][y] = modImage[x][y_coord]

        y_coord = y_coord + 1
    # cutImage = makeZeroPixel(drawImage,90,140,140,200,True,True)
    # cutImage = makeZeroPixel(cutImage,90,140,0,105,True,True)
    noiseFreeCluster = noiseRemovalCluster(drawImage)
    noiseFreeImage = removeNoise(drawImage,noiseFreeCluster)
    tempCropImageArray[k] = drawImage

    plt.imshow(drawImage)
    plt.show()

for i in range(32,40):
  if i%2 == 0:
    plt.imshow(cropImageArray[i])
    plt.show()

loopImageShape = np.array(cropImageArray[40].shape)
for k in range(32,50):
  if k % 2 == 0:
    cropImage = copy.deepcopy(cropImageArray[k][:,50:loopImageShape[1]])
    drawImage = copy.deepcopy(cropImageArray[k])
    cropShape = np.shape(cropImage)

    for i in range(cropShape[0]):
      for j in range(45,cropShape[1]):
        cropImage[i][j] = 0
    slist = getNonZeroPixelRegion(cropImage)
  
    modImage = modifiedImage(cropImage,slist)
    
    for x in range(loopImageShape[0]):
      y_coord = 0
      for y in range(50,loopImageShape[1]):
        drawImage[x][y] = modImage[x][y_coord]

        y_coord = y_coord + 1
    cutImage = makeZeroPixel(drawImage,90,140,0,100,True,True)
    cutImage = makeZeroPixel(cutImage,100,140,140,190,True,True)

    tempCropImageArray[k] = cutImage

    plt.imshow(cutImage)
    plt.show()

plt.imshow(tempCropImageArray[48])

loopImageShape = np.array(cropImageArray[40].shape)
for k in range(62,80):
  if k % 2 == 0:
    cropImage = copy.deepcopy(cropImageArray[k])
    drawImage = copy.deepcopy(cropImageArray[k])
    cropShape = np.shape(cropImage)

    # for i in range(cropShape[0]):
    #   for j in range(45,cropShape[1]):
    #     cropImage[i][j] = 0
    slist = getNonZeroPixelRegion(cropImage)
  
    modImage = modifiedImage(cropImage,slist)
    
    for x in range(loopImageShape[0]):
      y_coord = 0
      for y in range(0,loopImageShape[1]):
        drawImage[x][y] = modImage[x][y_coord]

        y_coord = y_coord + 1
    # cutImage = makeZeroPixel(drawImage,90,140,0,100,True,True)
    # cutImage = makeZeroPixel(cutImage,100,140,140,190,True,True)

    tempCropImageArray[k] = drawImage

    plt.imshow(drawImage)
    plt.show()

print( tempCropImageArray[24].shape)

import numpy as np
import cv2

from skimage import color
from skimage import io

from google.colab.patches import cv2_imshow
img = tempCropImageArray[24]
gray = color.rgb2gray(tempCropImageArray[24])
gray = np.uint8(gray)

# img = np.array(img, dtype=np.uint16)
# gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

blurred = cv2.medianBlur(gray, 25) #cv2.bilateralFilter(gray,10,50,50)

minDist = 100
param1 = 30 #500
param2 = 50 #200 #smaller value-> more false circles
minRadius = 5
maxRadius = 100 #10

# docstring of HoughCircles: HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]]) -> circles
circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, 1, minDist, param1=param1, param2=param2, minRadius=minRadius, maxRadius=maxRadius)

if circles is not None:
    circles = np.uint16(np.around(circles))
    for i in circles[0,:]:
        cv2.circle(img, (i[0], i[1]), i[2], (0, 255, 0), 2)

# Show result for testing:
# cv2_imshow(img)
plt.imshow(img)
plt.show()
# cv2.waitKey(0)
# cv2.destroyAllWindows()

for i in range(22,32):
  if i % 2 == 0:
      subbList = noiseRemovalCluster(tempCropImageArray[i])
      noiseFree =  removeNoise(tempCropImageArray[i],subbList)
      # plt.imshow(tempCropImageArray[i])
      # plt.show()
      # tempCropImageArray[i] = noiseFree
      # plt.imshow(noiseFree)
      # plt.show()

for i in range(101,116):
   if i % 2 == 0:
      # dilImage = getDilatedImage(tempCropImageArray[i])
      # tempCropImageArray[i] = dilImage
      cuttImage = copy.deepcopy(tempCropImageArray[i])
      cuttImage = makeZeroPixel(cuttImage,0,0,150,220,False,True)
      tempCropImageArray[i] = cuttImage

MulImage = copy.deepcopy(tempCropImageArray[116])
MulImage = np.array(MulImage) * 9
print(tempCropImageArray[116][100])

print(np.nonzero(tempCropImageArray[116][100]))

print(np.max(np.nonzero(MulImage)))

# for i in range(38,50):
#   tempCropImageArray[i] = getDilatedImage(tempCropImageArray[i])
  # i = dilImage
ind = 40
cropImage = tempCropImageArray[ind]
kernel = np.ones((5,5), np.uint8)
    
  # The first parameter is the original image,
  # kernel is the matrix with which image is 
  # convolved and third parameter is the number 
  # of iterations, which will determine how much 
  # you want to erode/dilate a given image. 
  # img_erosion = cv2.erode(img, kernel, iterations=1)
img_dilation = cv2.dilate(cropImage, kernel, iterations=1)
tempCropImageArray[ind] = img_dilation
plt.imshow(img_dilation)
plt.show()

testImage = tempCropImageArray[150]
plt.imshow(tempCropImageArray[56])
plt.show()

for i in range(50,172):
 if i % 2 == 0 :
  for j in range(loopImageShape[0]):
   for k in range(80,loopImageShape[1]):
     tempCropImageArray[i][j][k] = 0

# for i in range(50,290):
#   if i % 2 == 0:
#       subbList = noiseRemovalCluster(tempCropImageArray[i])
#       noiseFree =  removeNoise(tempCropImageArray[i],subbList)
#       tempCropImageArray[i] = noiseFree

for i in range(290,320):
 if i % 2 == 0 :
  for j in range(loopImageShape[1]):
   for k in range(0,92):
     tempCropImageArray[i][k][j] = 0

refArray = []
refArray2 = []
for i in range(100,200):
  # refArray.append(tempCropImageArray[i])
  
  if i % 2 == 0:
    # refArray.append(tempCropImageArray[i])
    refArray.append(tempCropImageArray[i])
    # a=1
  else:

    #subbList = noiseRemovalCluster(tempCropImageArray[i])
    # noiseFree =  removeNoise(tempCropImageArray[i],subbList)
    # noiseFree = makeZeroPixel(tempCropImageArray[i],0,len(tempCropImageArray[i][0]),0,0,True,False)
    # #refArray.append(tempCropImageArray[i])   
    # refArray.append(noiseFree)
    # tempCropImageArray[i-1] = tempCropImageArray[i]
    refArray.append(tempCropImageArray[i])

    # tempCropImageArray[i] = noiseFree
    # plt.imshow(noiseFree)
    # plt.show()
    # refArray.append(tempCropImageArray[i-1])

for i in range(100,200):
  if i % 2 == 0 :
    plt.imshow(tempCropImageArray[i])
    plt.show()

pip install trimesh

verts, faces, norm, val = measure.marching_cubes_lewiner(np.array(refArray),300, step_size=1, allow_degenerate=True) 
x,y,z = zip(*verts)
print(len(verts))

colormap=['rgb(236, 236, 212)','rgb(236, 236, 212)']

   fig = FF.create_trisurf(x=x,
                       y=y, 
                       z=z, 
                       plot_edges=False,
                       colormap=colormap,
                       simplices=faces,
                       edges_color = 'rgb(0, 0, 0)', 
                       backgroundcolor='rgb(64, 64, 64)',
                       title="Interactive Visualization")
   iplot(fig)

import trimesh
# mesh = trimesh.load_mesh('mesh.stl')
mesh = trimesh.Trimesh(vertices=verts,
                       faces=faces
                       )
mesh.show()

mesh = trimesh.load_mesh('mesh3.stl')

mesh.show()

pip install numpy-stl

print(np.array(verts))

print(vertices)

import numpy as np
from stl import mesh
vertices = np.array(verts)
faces2 = np.array(faces)

# Define the 8 vertices of the cube
# vertices = np.array([\
#     [-1, -1, -1],
#     [+1, -1, -1],
#     [+1, +1, -1],
#     [-1, +1, -1],
#     [-1, -1, +1],
#     [+1, -1, +1],
#     [+1, +1, +1],
#     [-1, +1, +1]])
# Define the 12 triangles composing the cube
# faces = np.array([\
#     [0,3,1],
#     [1,3,2],
#     [0,4,7],
#     [0,7,3],
#     [4,5,6],
#     [4,6,7],
#     [5,1,2],
#     [5,2,6],
#     [2,3,6],
#     [3,7,6],
#     [0,1,5],
#     [0,5,4]])

# Create the mesh
cube = mesh.Mesh(np.zeros(faces2.shape[0], dtype=mesh.Mesh.dtype))
for i, f in enumerate(faces2):
    for j in range(3):
        cube.vectors[i][j] = vertices[f[j],:]

# Write the mesh to file "cube.stl"
cube.save('mesh3.stl')

subList.sort(key=lambda x: x.length, reverse=True)

for j in range(1):
  for i in range(subList[0].end + 1, 150):
    imgg[j][i] = 0
# for i in subList:
#   print(i.start)
#   print(i.end)
#   print(i.length)

print(imgg[0])

refArray = []
refArray2 = []
for i in range(0,100):
  if i % 2 == 0:
    refArray.append(cropImageArray[i])
  else :
    refArray.append(cropImageArray[i-1])
  # plt.imshow(cropImageArray[i])
  # plt.show()

for i in refArray[40:60]:
  plt.imshow(i)
  plt.show()

noiseFreeImage = []
count = 40
for i in refArray[40:41]:
  # if count == 298:
  #   sig = 0.8
  # else:
  #   sig = 0.5
  segments_fz = felzenszwalb(i, scale=50, sigma=0.5, min_size=20)
  #segments_fz = slic(i, n_segments=5,compactness=0.01, multichannel=False)

  # segments_fz = felzenszwalb(i, scale=30, sigma=1, min_size=50)
  a = np.array(segments_fz)
  unique, counts = np.unique(a, return_counts=True)
  dctn = dict(zip(unique, counts))
  sort_orders = sorted(dctn.items(), key=lambda x: x[1], reverse=True)
  keyArray = list(dict(sort_orders).keys())
  # if keyArray[0] == 0 : 
  #   seg = keyArray[1]
  # else :
  #   seg = keyArray[0]
  seg = keyArray[1]
  mask = segments_fz == seg
  shp = np.array(segments_fz.shape)
  modImage = copy.deepcopy(i)
  for i in range(shp[0]):
    for j in range(shp[1]):
      if mask[i][j] == False:
        modImage[i][j] = 0
  # print(count)
  plt.imshow(modImage)
  plt.show()
  # count = count + 1
  noiseFreeImage.append(modImage)

def getDilatedImage(lostImage):
  cropImage = lostImage
  kernel = np.ones((5,5), np.uint8)
    
  # The first parameter is the original image,
  # kernel is the matrix with which image is 
  # convolved and third parameter is the number 
  # of iterations, which will determine how much 
  # you want to erode/dilate a given image. 
  # img_erosion = cv2.erode(img, kernel, iterations=1)
  img_dilation = cv2.dilate(cropImage, kernel, iterations=1)
  
  return img_dilation

print(refArray[40].shape)

# im = cv.imread('test.jpg')
# img = np.full((230,150,3),  np.uint8)
img = np.array(refArray[40], dtype=np.uint8)
# imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# plt.imshow(imgray)
# plt.show()
ret, thresh = cv2.threshold(img, 127, 255, 0)
contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(img, contours, -1, (0, 255, 0), 3)
  
plt.imshow(img, cmap='gray')
plt.show()

chk = refArray[40][80:180, 0:150]
# plt.imshow(chk)
# plt.show()
print(chk[0])
# for i in range(np.array(chk.shape)[0]):
for j in range(np.array(chk.shape)[0]):
  print(chk[j])

noiseNP = np.array(noiseFreeImage)
print(noiseNP.shape)

dilated = []
for i in noiseNP:
  kernel = np.ones((3,3), np.uint8)
  
# The first parameter is the original image,
# kernel is the matrix with which image is 
# convolved and third parameter is the number 
# of iterations, which will determine how much 
# you want to erode/dilate a given image. 
# img_erosion = cv2.erode(img, kernel, iterations=1)
  img_dilation = cv2.dilate(i, kernel, iterations=1)
  dilated.append(img_dilation)

verts, faces, norm, val = measure.marching_cubes_lewiner(np.array(dilated),300, step_size=1, allow_degenerate=True) 
x,y,z = zip(*verts)
print(len(verts))

import trimesh
# mesh = trimesh.load_mesh('mesh.stl')
mesh = trimesh.Trimesh(vertices=verts,
                       faces=faces
                       )
mesh.show()

Seg ( 40 - 42 )
segments_fz = felzenszwalb(i, scale=10, sigma=0.5, min_size=50)

def make_lungmask(img, display=True):
    row_size= img.shape[0]
    col_size = img.shape[1]
    
    mean = np.mean(img)
    std = np.std(img)
    img = img-mean
    img = img/std
    # Find the average pixel value near the lungs
    # to renormalize washed out images
    middle = img[int(col_size/5):int(col_size/5*4),int(row_size/5):int(row_size/5*4)] 
    mean = np.mean(middle)  
    max = np.max(img)
    min = np.min(img)
    # To improve threshold finding, I'm moving the 
    # underflow and overflow on the pixel spectrum
    img[img==max]=mean
    img[img==min]=mean
    #
    # Using Kmeans to separate foreground (soft tissue / bone) and background (lung/air)
    #
    kmeans = KMeans(n_clusters=2).fit(np.reshape(middle,[np.prod(middle.shape),1]))
    centers = sorted(kmeans.cluster_centers_.flatten())
    threshold = np.mean(centers)
    thresh_img = np.where(img<threshold,1.0,0.0)  # threshold the image

    # First erode away the finer elements, then dilate to include some of the pixels surrounding the lung.  
    # We don't want to accidentally clip the lung.

    eroded = morphology.erosion(thresh_img,np.ones([3,3]))
    dilation = morphology.dilation(eroded,np.ones([8,8]))

    labels = measure.label(dilation) # Different labels are displayed in different colors
    label_vals = np.unique(labels)
    regions = measure.regionprops(labels)
    good_labels = []
    for prop in regions:
        B = prop.bbox
        if B[2]-B[0]<row_size/10*9 and B[3]-B[1]<col_size/10*9 and B[0]>row_size/5 and B[2]<col_size/5*4:
            good_labels.append(prop.label)
    mask = np.ndarray([row_size,col_size],dtype=np.int8)
    mask[:] = 0

    #
    #  After just the lungs are left, we do another large dilation
    #  in order to fill in and out the lung mask 
    #
    for N in good_labels:
        mask = mask + np.where(labels==N,1,0)
    mask = morphology.dilation(mask,np.ones([10,10])) # one last dilation

    if (display):
        fig, ax = plt.subplots(3, 2, figsize=[12, 12])
        ax[0, 0].set_title("Original")
        ax[0, 0].imshow(img, cmap='gray')
        ax[0, 0].axis('off')
        ax[0, 1].set_title("Threshold")
        ax[0, 1].imshow(thresh_img, cmap='gray')
        ax[0, 1].axis('off')
        ax[1, 0].set_title("After Erosion and Dilation")
        ax[1, 0].imshow(dilation, cmap='gray')
        ax[1, 0].axis('off')
        ax[1, 1].set_title("Color Labels")
        ax[1, 1].imshow(labels)
        ax[1, 1].axis('off')
        ax[2, 0].set_title("Final Mask")
        ax[2, 0].imshow(mask, cmap='gray')
        ax[2, 0].axis('off')
        ax[2, 1].set_title("Apply Mask on Original")
        ax[2, 1].imshow(mask*img, cmap='gray')
        ax[2, 1].axis('off')
        
        plt.show()
    return mask*img

make_lungmask(cropImage)

import matplotlib.pyplot as plt
import numpy as np

from skimage.data import astronaut
from skimage.color import rgb2gray
from skimage.filters import sobel
from skimage.segmentation import felzenszwalb, slic, quickshift, watershed
from skimage.segmentation import mark_boundaries
from skimage.util import img_as_float

# img = img_as_float(imgs[0])
img = tempCropImageArray[24]
segments_fz = felzenszwalb(img, scale=100, sigma=0.5, min_size=50)
# segments_slic = slic(img,n_segments=500,compactness=0.01, enforce_connectivity=True)
segments_slic = slic(img, n_segments=100,compactness=0.01, multichannel=False)

# segments_quick = quickshift(img, kernel_size=3, max_dist=6, ratio=0.5)
gradient = sobel(rgb2gray(img))
segments_watershed = watershed(gradient, markers=200, compactness=0.001)

print(f"Felzenszwalb number of segments: {len(np.unique(segments_fz))}")
print(f"SLIC number of segments: {len(np.unique(segments_slic))}")
# print(f"Quickshift number of segments: {len(np.unique(segments_quick))}")

fig, ax = plt.subplots(2, 2, figsize=(10, 10), sharex=True, sharey=True)

ax[0, 0].imshow(mark_boundaries(img, segments_fz))
ax[0, 0].set_title("Felzenszwalbs's method")
ax[0, 1].imshow(mark_boundaries(img, segments_slic))
ax[0, 1].set_title('SLIC')
# ax[1, 0].imshow(mark_boundaries(img, segments_quick))
# ax[1, 0].set_title('Quickshift')
ax[1, 1].imshow(mark_boundaries(img, segments_watershed))
ax[1, 1].set_title('Compact watershed')

for a in ax.ravel():
    a.set_axis_off()

plt.tight_layout()
plt.show()